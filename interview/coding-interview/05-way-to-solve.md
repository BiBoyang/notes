常见的思路

数组，字符串动归
树，递归，递归绝对比非递归简单得多
求解解的个数 回溯
对于遍历树优先采用层序遍历

面对一道题，要怎么做呢?

1. 基本操作步骤
2. 约束条件
3. 是否有 O(1) 的数学公式
4. 采用数学归纳法证明


最后，看程序设计的思路如何，编程风格如何，细节是否考虑到了，是否有内存泄露，是否采用了最优算法，程序的可扩展性如何，能否举一反三。

有些题看起来是树，实际上是利用递归关系的，或者只是利用到了一个性质，但本质上是其他问题

分治法

主定理 
T(n) = a T(n/b) + f(n), if f(n) ∈ O(n^d), d >=0
T(n)∈ { 
    O(n^d), a < b^d;
    O(n^d logn), a = b^d;
    O(n^(logba), a > b^d;
}

对于O(nlogn)的算法 T(n) = 2T(n/2) + O(n)

证明一般采用数学归纳法，反证法

贪婪一般需要预排序，证明贪婪成立可以采用数学归纳法，或者证明不会有更好的方法

已知最短路径求法，要求最大路径，可以把最大路径取负值即可。

面试中的动态规划大致分为单向递归（首或者尾）， O（n2）或者O(n3) 距离递归,  O(mn)递归，有限定条件的NP (背包）。 每种类型听几节课， 懂了基本原理即可。 至于贪心和带状态的dp(走道铺砖）一类的dp, 至少我没在面试中遇到过， 因为很难临时造出一道这样的题目， 面试官一般也没这个能力和时间来思考题目是不是严谨。 贪心准备下加油站， 迪杰斯特拉， 最小生成树就足够了。
